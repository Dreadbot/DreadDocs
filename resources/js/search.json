[[{"i":"welcome-to-the-dreaddocs","l":"Welcome to the DreadDocs!","p":["Work in Progress!","Welcome to our Docs! Here you will find Information about WPILib, robot programming, and Java."]},{"i":"where-to-start","l":"Where to Start?","p":["Consider starting in Java, or if you know about Java and OOP, maybe start in Project Structure."]},{"l":"Getting Started","p":["If you are using a robotics computer, everything will be set up for you already!","This tutorial is focused on a Windows installation, if you need help with installation on a different OS, reach out on the Discord server","To get started, head to the WPILib Installation Guide and click the blue download button (It should be platform specific).","Once that has finished installing, right click on the .iso file and click mount.","After mounting the file, open the WPILibInstaller.exe executable.","Follow all of the prompts.","After that, WPILib should be installed"]}],[{"l":"Java"},{"i":"what-is-java","l":"What is Java?","p":["Java is a programming language that turns source code into 1s and 0s that the computer can understand. We use Java to tell our robot what to do by using variables, functions, classes, and APIs."]}],[{"l":"Variables","p":["A variable is kind of like a named box that holds something.","Here is a quick example in Java:","To create a variable, you need 4 things:","You need a type, a type tells us what that \"something\" is. In this case our type is a boolean which stores either a true or false.","You need a name, which in this case is isRobotOn, you will use this name to refrence the variable later.","You need an equals sign, this is how we tell Java that we want to assign a variable to a value.","And lastly, you need a value, which in this case is false."]},{"l":"Common Types in Robot Programming and Their Values","p":["Type","Value","int","Whole numbers (such as 1, 2, -3, etc.)","double","Numbers with a decimal (such as 1.234)","boolean","Can be true or false","More information on booleans is available at Control Flow. More information on types is available at Types. For more information of variables, consider checking out the W3 Schools Java Tutorial."]}],[{"l":"Functions","p":["A Function is a way of packaging code so that we can reuse it. A function can have inputs and outputs, so they can be quite a useful tool in Java programming.","Here is a simple example:","There is a lot going on here but we will focus on the function declaration. to declare a function, we simply need a type and a name. The type tells us what the function will return, in this case that is void, which is nothing. The name of the function is how we reference it. After the name comes the parentheses, which hold the paramters of the function, we will go into depth about parameters later. In this case there are no parameters, so it's just the parentheses. Lastly, we have the curly brackets. These tell Java where the code for the function starts and ends."]},{"l":"Parameters and Returns","p":["Sometimes, we want a function to do something based on an input, and give an output. Thats where parameters and returns come in. Here is an example of parameters and returns","To add parameters to a function, simply give the parameter a type and a name and add a comma in between each parameter. you can user parameters as a kind of local variable that only exists inside the function declaration. To return something from a function, use the return keyword. You can pass either a variable or an expression (as we have in this case). Notice how we changed the functions type to reflect what we are returning. To call any function, just write the name with a pair of parentheses in which you add any parameters the function has. For more information on types when working with functions, check out Types"]}],[{"l":"Classes","p":["Classes are one of the most important features of Java. They allow us to represent and package code in a way that is easy and convient to reuse. Lets look at an example:"]},{"l":"Modifiers","p":["There is a lot going on here, but let's break it down. First, let's focus on modifiers. public and private before the variables, classes, and functions are modifiers. Modifiers allow us to give or restrict access to something. In this example, the variable robotAge is private, so that means only the class itself has access to it, and nothing else can read or write it. The variable isrobotOn however, is public, meaning any piece of code can read and write to it.","One important clarification to make is that these are not technically variables, they are members, that means they act slightly differently than variables. We will touch more on it later."]},{"l":"Constructor","p":["Next, let's talk about the constructor. The constructor is run whenever a new instance is created. This is our init \"function\". It looks sort of like a Function, but it doesn't have a return type, and the name of the function is capitalized and is the same name as the class. You should put anything that needs to be initialized when a new instance is created here, such as setting up members and calling functions.","Even though the constructor is not a function, you can still pass in input arguments! See Functions for more information."]},{"l":"Dot Operator","p":["You may have noticed that the member initialization inside the constructor looks different than a normal variable declaration. The two things in front of the variable are the this keyword and the member operator, or \"dot\" as many people call it. Let's break it down:","The this keyword refers to the parent class that the code is running in, so in this case, this means the Robot class object. Next, let's talk about the member operator, or \"dot\" as almost everyone calls it. It allows you to reference a member, method, or subclass that is declared within the class. On the left of the dot operator, you put the name of the object you want to reference from, and on the right, you put the name of the member, method, or subclass you want to reference. In this case, we reference the Robot class, and then we reference the robotAge member. This may seem redundant, but we use this to clarify which variables are arguments and which are members, allowing us to have the same named arguments as members. However, if you differently named arguments and members or no arguments at all, it is not necessary, but it is a best practice."]},{"l":"Methods","p":["Another piece of classes we have yet to talk about are methods. Methods are special functions inside of classes, and they work basically the same way. however, you need to include a modifier for them to function properly. to call methods, you simply use the dot operator, such as:","As you can see, you call a method the same as a function, just with the dot operator and reference to a class."]},{"l":"Instantiation","p":["We have a class, now how do we use it? Classes on their own do not run their code unless they are instantiated, which means making a live, working copy of the \"blueprint\" that is the class. It's kind of like a house, the instance is the actual house and the blueprint is the class. Each instance is its own \"ecosystem\" of members and methods, which means that each instance can have different values for each of the different members. Such as 2 Robot instances having different values for isRobotOn. So how do we create a new instance of a class?","Whenever we make a new instance, we need to set it to a variable so that we can reference it later. You probably have also noticed that the type of the variable is Robot! Because we need a type for our instance, and its not one of the primitives, we need to use the class as the type, which is as simple as typing the name of the class you are instantiating. Next, let's look at the new keyword, this tells java we want a new instance of whatever class comes after the new keyword. Then we add two parentheses to call the constructor and voila! You have your very own instance."]}],[{"l":"Flow Control","p":["Flow Control is the way your program can make decisions while its running. Let's look at an example!","This is an if statement, and the code inside the block is only ran if the expression resolves to boolean value that is true. Because the expression of isRobotOn resolves to true, the code inside the if statement block is ran, printing out \"Robot is on!\" to the console. Let's look at some other expressions:","Here, we can see the not operator and the equals operator. The not operator resolves to the inverse of the boolean value that comes after it, so because isRobotOn is false, its is inverted to true, so the code inside the block is ran. The equals operator resolves to true only if both side of the operator are equivelent to each other.","What if you wanted to do something if the if statement failed? You would use an if else block! Here is an example of one:","Here we can see the use of a new keyword, else, which sits right after the closing curly bracket of the if statement and is followed by another code block. This code block is only ran if the if statement doesn't activate (such as the expression resolving to false). But wait, Theres more! You can also check for another condtion if the if statement fails by using an else if block!"]},{"l":"Operators","p":["!","=","==","||","And","Before we get to the table, we need to talk about the difference between a unary and a binary operator. A unary operator only operates on one value, and the value usally proceeds the operator (such as !isRobotOn). A binary operator operates on 2 values, one on the left hand side of the operator and one on the right hand side (such as 2 + 2); Given that, here is a table of the different types of boolean operators:","Equals","Greater or equal than","Greater than","Less or equal than","Less than","Meaning","Name","Not","Operator","Or","Resolves to the inverse the value given","Resolves to true if the left side resolves to true or the right side resolves to true.","Resolves to true only if both sides of operator are equivelent","Resolves to true only if left side is greater than the right side","Resolves to true only if left side is less than the right side","Resolves to true only if the left side is greater than or equal to the right side","Resolves to true only if the left side is less than or equal to the right side","Resolves to true only if the left side resolves to true and the right side resolves to true"]}],[{"l":"APIs"}],[{"l":"Types"},{"i":"what-are-types","l":"What Are types?","p":["Java is a statically typed langauge. This means that we have to work with types. Types are how we tell Java what something is or returns. In variables, we looked at this example:","Here, we tell java what the data that the variable contains is. In this case, the variable isRobotOn is of type boolean.","In functions, we looked at this example:","In this example, we tell Java what this function will return, this allows us to guarantee* that we will get a return value of type int. This allows has the side effect of being able to use Code Completion on a lot more objects and variables that we would be able to otherwise.* This is true for about 99% of cases"]},{"l":"Primitives","p":["A fracional number that goes up to 15 decimal places","A fracional number that goes up to 7 decimal places (1.234, etc.)","A number from -2147483648 to 2147483647","A number from -32768 to 32767","A number from 0 to 255","A single character","A true or false value","boolean","byte","char","double","float","int","Integers (1, 2, 3, etc.)","long","Meaning","Name","short","So far, all the types we have been looking at have been primitives. A primitive is a type that Java supplies us by default. You can tell which types are primitives as primitives always start with a lowercase. Here are some primitives:"]},{"l":"Other Types","p":["So far, we have only looked at primitives, but Java has more to offer then that! We are going to look at non-primitive data types. You can tell if a type is not a primitive if it starts with an uppercase.","For example:","How do we create types? Its super simple! We simply use the class name of the class we are instantiating as the type. For more information about instantiating classes, check out classes."]}],[{"l":"Project Structure","p":["Knowing project structure is very important to being able to collaboratively program effectively. It allows us to stay organized and find things easily and efficiently. However, to someone who is new to the project and programming in general it can be very daunting to figure out where everything is and what it does. The different folders inside this section will be laid out similarly to how our code is usally organized.","This layout assumes you are in src/"]}],[{"l":"main","p":["This is where the main portion of our code is kept."]}],[{"l":"java","p":["This is where we keep all of our Java source code."]}],[{"l":"robot","p":["This is where you will find all of our core robot code."]}],[{"l":"commands","p":["This is where we keep all of our commands. This are specific actions that we can run on events. They will usally be in a subsystem specific folder."]}],[{"l":"subsystems","p":["This is where we keep all of our subsystems. You can think of a subsystem as a specific part of the robot. For example, a grabber would be considered a subsystem."]}],[{"i":"constantsjava","l":"Constants.java","p":["Here you will find all of our constant values, anything like a gear ratio, wheel circumference, or controller port will be found here."]}],[{"i":"mainjava","l":"Main.java","p":["This is the entry point to the robot code. This is the first thing that is run when the robot turns on. We rarely if ever have to edit this."]}],[{"i":"robotjava","l":"Robot.java","p":["This contains the initalization of the command based system that we use, as well as some low level robot things such as path loading and generation."]}],[{"i":"robotcontainerjava","l":"RobotContainer.java","p":["This is were we instanciate our subsystems, bind our buttons, and setup default commands. This is the file that you will come back to the most."]}],[{"l":"util","p":["This is where we keep all of our utilities, or things that we reuse season after season. You see a lot of files reference the utils folder so its good to familiarize yourself with them."]}],[{"l":"deploy","p":["Anything that needs to be deployed onto the roborio is put in this folder. The most common thing we need to deploy are paths."]}],[{"l":"test","p":["We write all of our unit tests in this folder. The rest of the path is /Java/frc/Robot"]}],[{"l":"Git"}],[{"l":"Robot Programming","p":["This section goes over some important concepts of programming for WPILib robots. Checkout Java for more information on general programming."]}],[{"l":"Command Based Programming"},{"i":"what-is-command-based-programming","l":"What is Command Based Programming?","p":["Command Based programming is the design pattern we use to link together actions and subsystems. We use this design pattern because it makes the code easier to write, read, and does it in less lines of code. We call actions commands in Java, which are all the differen things that subsystems can do."]},{"i":"what-is-a-command","l":"What is a command?","p":["A command encodes an action that a subsystem can preform. Here is an example:","Please reference classes for more information about inheritance","A command is split into 4 parts: The constructor, The intialize function, the execute function, and the end function. The constructor takes in 1 argument if it is applicable, which is the subsystem that the command acts on. The intialize function is executed one time when the command is scheduled."]}]]